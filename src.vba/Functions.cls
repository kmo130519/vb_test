Option Explicitnn'###################################################################################n' Author: YK Jeonn'###################################################################################nnPublic Function ToBinary(ByVal n As Double) As Stringnn'This function return the binary expansion of N where N is natural number - ykjeonnnDim temp As StringnnOn Error GoTo ErrorHandlernn    If Int(n) <> n Or n < 0 Thenn        MsgBox "INPUT MUST BE A NONNEGATIVE INTEGER"n        Exit Functionn        n    End Ifn    n    temp = ""n    n    Don    n        temp = CStr(n Mod 2) & tempnn        n = n \ 2nn    Loop While n > 0n    n    ToBinary = tempn    nExit FunctionnnErrorHandler:n    n    MsgBox "FAIL IN BINARY CONVERSION"n    Exit FunctionnnEnd FunctionnnPublic Function DigitConversion( _nByVal n As Double, _nByVal BaseNum As Long) As StringnnDim temp As StringnnOn Error GoTo ErrorHandlernn    If Int(n) <> n Or n < 0 Thenn    n        MsgBox "INPUT MUST BE A NONNEGATIVE INTEGER"n        Exit Functionn        n    Elsen    n        If BaseNum = 1 Thenn        n            DigitConversion = "-1"n            n        Elsen    n            temp = ""n            n            Don            n                temp = CStr(n Mod BaseNum) & tempn        n                n = n \ BaseNumn        n            Loop While n > 0n            n            DigitConversion = tempn        n        End Ifn    n    End Ifn    nExit FunctionnnErrorHandler:n    n    MsgBox "FAIL IN DIGIT CONVERSION"n    Exit FunctionnnEnd FunctionnnPublic Sub ReturnPermutator( _nByVal Dimension As Long, _nByVal BaseNum As Long, _nByRef PermutArray() As Long)nnDim i As LongnDim j As LongnnDim temp As LongnDim Strtemp As Stringnn    temp = BaseNum ^ (Dimension) - 1nn    ReDim PermutArray(0 To temp, 1 To Dimension) As Longn    n    For i = 0 To tempn    n        Strtemp = StrReverse(DigitConversion(i, BaseNum))n        n        For j = 1 To Len(Strtemp)n        n            PermutArray(i, j) = CLng(Mid(Strtemp, j, 1))n        n        Next jn        n        For j = Len(Strtemp) + 1 To Dimensionn        n            PermutArray(i, j) = 0n        n        Next jnn    Next innEnd SubnnPublic Function Summation(ByRef values() As Double) As DoublennDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Doublen    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = 0n    n    For i = IndexMin To IndexMaxn    n        temp = temp + values(i)n    n    Next in    n    Summation = tempnnEnd FunctionnnPublic Function max(ByVal x As Double, ByVal y As Double) As Doublenn    max = (x + y + Abs(x - y)) * 0.5nnEnd FunctionnnPublic Function min(ByVal x As Double, ByVal y As Double) As Doublenn    'Min = x + y - Max(x, y)n    min = (x + y - Abs(x - y)) * 0.5nnEnd FunctionnnPublic Function max_date(ByVal x As Date, ByVal y As Date) As Datenn    max_date = (x + y + Abs(x - y)) * 0.5nnEnd FunctionnPublic Function min_date(ByVal x As Date, ByVal y As Date) As Datenn    min_date = (x + y - Abs(x - y)) * 0.5nnEnd FunctionnnPublic Function ReturnMax(ByRef values() As Double) As DoublennDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Doublen    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = values(IndexMin)n    n    If IndexMax = IndexMin Thenn    n        ReturnMax = values(IndexMin)n        n    Elsen    n        For i = IndexMin + 1 To IndexMaxn        n            temp = max(temp, values(i))n        n        Next in        n        ReturnMax = tempn        n    End IfnnEnd FunctionnnPublic Function ReturnMin(ByRef values() As Double) As DoublennDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Doublen    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = values(IndexMin)n    n    If IndexMax = IndexMin Thenn    n        ReturnMin = values(IndexMin)n        n    Elsen    n        For i = IndexMin + 1 To IndexMaxn        n            temp = min(temp, values(i))n        n        Next in        n        ReturnMin = tempn        n    End IfnnEnd FunctionnnPublic Function ReturnMinDate(ByRef values() As Date) As DatennDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Daten    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = values(IndexMin)n    n    If IndexMax = IndexMin Thenn    n        ReturnMinDate = values(IndexMin)n        n    Elsen    n        For i = IndexMin + 1 To IndexMaxn        n            temp = min(temp, values(i))n        n        Next in        n        ReturnMinDate = tempn        n    End IfnnEnd FunctionnnPublic Function lReturnMax(ByRef values() As Long) As LongnnDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Doublen    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = values(IndexMin)n    n    If IndexMax = IndexMin Thenn    n        lReturnMax = values(IndexMin)n        n    Elsen    n        For i = IndexMin + 1 To IndexMaxn        n            temp = max(temp, values(i))n        n        Next in        n        lReturnMax = tempn        n    End IfnnEnd FunctionnnPublic Function lReturnMin(ByRef values() As Long) As LongnnDim IndexMax As LongnDim IndexMin As LongnDim i As IntegernDim temp As Doublen    n    IndexMin = LBound(values)n    IndexMax = UBound(values)n    temp = values(IndexMin)n    n    If IndexMax = IndexMin Thenn    n        lReturnMin = values(IndexMin)n        n    Elsen    n        For i = IndexMin + 1 To IndexMaxn        n            temp = min(temp, values(i))n        n        Next in        n        lReturnMin = tempn        n    End IfnnEnd FunctionnnPublic Function Combin(ByVal n As Long, ByVal m As Long) As DoublennDim i As LongnDim k As LongnDim temp As Doublen    n    temp = 1nn    If Int(n) <> n Or Int(m) <> m Or n < m Thenn    n        MsgBox "Input Values for Combination function are not valid"n        Exit Functionn        n    Elsen    n        If m = 0 Or m = n Thenn        n            Combin = 1n        n        ElseIf m = 1 Or n - m = 1 Thenn        n            Combin = nn            n        Elsen        n            k = max(n - m, m)n            n            For i = 0 To n - k - 1n                n                temp = temp * (n - i) / (n - k - i)n            n            Next in            n            Combin = tempn                        n        End Ifn        n    End Ifn        nEnd FunctionnnPublic Sub ReturnTangentVector( _nByRef p1() As Double, _nByRef p2() As Double, _nByRef TangentVector() As Double)nnDim i As LongnDim j As LongnDim Dimension As Longnn    Dimension = UBound(p1(), 1) - LBound(p1(), 1) + 1n    n    ReDim TangentVector(1 To Dimension) As Doublen    n    For i = LBound(p1(), 1) To UBound(p1(), 1)n    n        TangentVector(i - LBound(p1(), 1) + 1) = _n        (p2(i) - p1(i))n    n    Next innEnd SubnnPublic Function ReturnVectorNorm( _nByRef p1() As Double, _nByRef p2() As Double, _nOptional ByVal NormIndex As Long = 2) As DoublennDim i As LongnDim v() As DoublennDim temp As DoublennDim Dimension As Longnn    Dimension = UBound(p1(), 1) - LBound(p1(), 1) + 1n    n    ReDim v(1 To Dimension) As Doublen    n    For i = LBound(p1(), 1) To UBound(p1(), 1)n    n        v(i - LBound(p1(), 1) + 1) = Abs(p2(i) - p1(i))n    n    Next inn    If NormIndex = 0 Thenn    n        temp = ReturnMax(v())n        n        ReturnVectorNorm = tempn        n    Elsen    n        For i = 1 To Dimensionn        n            temp = temp + (v(i)) ^ (NormIndex)n        n        Next in        n        ReturnVectorNorm = (temp) ^ (1 / NormIndex)n        n    End IfnnEnd FunctionnnPublic Function Sorting_dbl( _nByRef values() As Double, _nByRef OrderedValues() As Double, _nOptional ByVal DataOdering As String = "ASC", Optional min_inx As Integer = -1, Optional max_inx As Integer = -1) As DoublennDim i As LongnDim j As LongnnDim IndexMax As LongnDim IndexMin As LongnDim SwapArray() As DoublenDim temp As DoublennOn Error GoTo ErrorHandlernn    IndexMax = UBound(values)n    IndexMin = LBound(values)n    n    ReDim OrderedValues(IndexMin To IndexMax) As Doublen    ReDim SwapArray(IndexMin To IndexMax) As Doublen    n    For i = IndexMin To IndexMaxn    n        SwapArray(i) = values(i)n    n    Next in    n    For i = IndexMin + 1 To IndexMaxn    n        temp = values(i)n        n        For j = i - 1 To IndexMin Step -1n    n            If SwapArray(j) > values(i) Thenn            n                SwapArray(j + 1) = SwapArray(j)n                SwapArray(j) = tempn                n            End Ifn    n        Next jn        n    Next in    n    If min_inx > 0 Thenn    n        IndexMin = min_inxn        n    End Ifn    n    If max_inx > 0 Thenn    n        IndexMax = max_inxn        n    End Ifn    n    ReDim OrderedValues(LBound(values) To LBound(values) + IndexMax - IndexMin) As Doublen    n    If LCase(DataOdering) = LCase("ASC") Thenn        n        For i = IndexMin To IndexMaxn        n            OrderedValues(LBound(values) + i - IndexMin) = SwapArray(i)n        n        Next in        n    Elsen    n        For i = IndexMin To IndexMaxn        n            OrderedValues(LBound(values) + i - IndexMin) = SwapArray(IndexMax - i + IndexMin)n        n        Next in    n    End Ifn    n    Sorting_dbl = 1n    n    Exit Functionn    nErrorHandler:nn    Sorting_dbl = -1n    n    Exit FunctionnnEnd FunctionnnPublic Function Sorting( _nByRef values() As Variant, _nByRef OrderedValues() As Variant, _nOptional ByVal DataOdering As String = "ASC") As DoublennDim i As LongnDim j As LongnnDim IndexMax As LongnDim IndexMin As LongnDim SwapArray() As VariantnDim temp As VariantnnOn Error GoTo ErrorHandlernn    IndexMax = UBound(values)n    IndexMin = LBound(values)n    n    ReDim OrderedValues(IndexMin To IndexMax) As Variantn    ReDim SwapArray(IndexMin To IndexMax) As Variantn    n    For i = IndexMin To IndexMaxn    n        SwapArray(i) = values(i)n    n    Next in    n    For i = IndexMin + 1 To IndexMaxn    n        temp = values(i)n        n        For j = i - 1 To IndexMin Step -1n    n            If SwapArray(j) > values(i) Thenn            n                SwapArray(j + 1) = SwapArray(j)n                SwapArray(j) = tempn                n            End Ifn    n        Next jn        n    Next in    n    If LCase(DataOdering) = LCase("ASC") Thenn        n        For i = IndexMin To IndexMaxn        n            OrderedValues(i) = SwapArray(i)n        n        Next in        n    Elsen    n        For i = IndexMin To IndexMaxn        n            OrderedValues(i) = SwapArray(IndexMax - i + IndexMin)n        n        Next in    n    End Ifn    n    Sorting = 1n    n    Exit Functionn    nErrorHandler:nn    Sorting = -1n    n    Exit FunctionnnEnd FunctionnnPublic Function Moment( _nByRef values() As Double, _nByVal MomentOrder As Long) As DoublennDim IndexMax As LongnDim IndexMin As LongnDim i As LongnDim temp As Doublen    n    temp = 0n    IndexMax = UBound(values)n    IndexMin = LBound(values)n    n    If IndexMax >= IndexMin Thenn    n        For i = IndexMin To IndexMaxn    n            temp = temp + values(i) ^ MomentOrder / (IndexMax - IndexMin + 1)n    n        Next in        n        Moment = tempn    n    Elsen    n        Moment = -999n        n    End IfnnEnd FunctionnnPublic Function CMoment( _nByRef values() As Double, _nByVal MomentOrder As Long) As DoublennDim i As LongnDim IndexMax As LongnDim IndexMin As LongnDim temp As DoublenDim Average As Doublen    n    temp = 0n    IndexMax = UBound(values)n    IndexMin = LBound(values)n    n    Average = Moment(values, 1)n    n    If MomentOrder = 1 Thenn    n        CMoment = Averagen    n    Elsen    n        If IndexMax > IndexMin Thenn    n            For i = IndexMin To IndexMaxn        n                temp = temp + (values(i) - Average) ^ MomentOrder / (IndexMax - IndexMin)n        n            Next in            n            CMoment = tempn            n        ElseIf IndexMax = IndexMin Thenn        n            CMoment = tempn            n        Elsen        n            CMoment = -999n            n        End Ifn        n    End IfnnEnd FunctionnnPublic Function ReturnAVG( _nByRef values() As Double) As Doublen    n    ReturnAVG = Moment(values(), 1)nnEnd FunctionnnPublic Function ReturnSTDEV( _nByRef values() As Double) As DoublennDim temp As Doublenn    temp = Sqr(CMoment(values(), 2))nn    If temp > 0 Thennn        ReturnSTDEV = Sqr(CMoment(values(), 2))n        n    Elsen    n        ReturnSTDEV = -1n        n    End IfnnEnd FunctionnnPublic Function ReturnNCSTDEV( _nByRef values() As Double) As DoublennDim IndexMax As LongnDim IndexMin As LongnDim i As LongnDim temp As Doublenn    temp = 0n    n    IndexMax = UBound(values)n    IndexMin = LBound(values)n    n    If IndexMax - IndexMin >= 0 Thenn        n        For i = IndexMin To IndexMaxn    n            temp = temp + values(i) * values(i) / (IndexMax - IndexMin + 1)n    n        Next in    n        ReturnNCSTDEV = Sqr(temp)nn    Elsen    n        ReturnNCSTDEV = -1n        n    End IfnnEnd FunctionnnPublic Function ReturnABSSTDEV( _nByRef values() As Double) As DoublennDim i As LongnDim IndexMax As LongnDim IndexMin As LongnDim Average As DoublenDim temp As Doublenn    temp = 0n    n    IndexMax = UBound(values)n    IndexMin = LBound(values)nn    If IndexMax > IndexMin Thenn    n        Average = ReturnAVG(values())n    n        For i = IndexMin To IndexMaxn    n            temp = temp + Abs(values(i) - Average) / (IndexMax - IndexMin)n    n        Next in        n        ReturnABSSTDEV = tempn    n    ElseIf IndexMax = IndexMin Thenn    n        ReturnABSSTDEV = 0n        n    Elsen    n        ReturnABSSTDEV = -999n        n    End IfnnEnd FunctionnnnFunction LogSummation( _nByRef ReturnArray() As Double, _nByVal MomentOrder As Long) As DoublennDim i As LongnDim IndexMax As LongnDim IndexMin As LongnDim LogReturn() As Doublenn    IndexMax = UBound(ReturnArray)n    IndexMin = LBound(ReturnArray)n        n    If IndexMax <= IndexMin + 1 Thenn        n        LogSummation = -999n        n        Exit Functionn        n    Elsen    n        ReDim LogReturn(IndexMin To IndexMax) As Doublen        n    n        n        For i = IndexMin To IndexMaxn            n            LogReturn(i) = Log(1 + ReturnArray(i))n        n        Next in        n            n        LogSummation = Summation(LogReturn())n        n    End IfnnEnd FunctionnnFunction LogMoment( _nByRef PriceArray() As Double, _nByVal MomentOrder As Long, _nOptional ByVal DateOrdering As String = "ASC") As DoublennDim i As LongnDim IndexMax As LongnDim IndexMin As LongnDim LogReturn() As Doublenn    IndexMax = UBound(PriceArray)n    IndexMin = LBound(PriceArray)n        n    If IndexMax <= IndexMin + 1 Thenn        n        LogMoment = -999n        n        Exit Functionn        n    Elsen    n        ReDim LogReturn(IndexMin To IndexMax - 1) As Doublen        n        If LCase(DateOrdering) = LCase("ASC") Thenn        n            For i = IndexMin To IndexMax - 1n                n                LogReturn(i) = Log(PriceArray(i + 1) / PriceArray(i))n            n            Next inn        Elsen        n            For i = IndexMin To IndexMax - 1n            n                LogReturn(i) = Log(PriceArray(i) / PriceArray(i + 1))n            n            Next in        n        End Ifn            n        LogMoment = Moment(LogReturn(), MomentOrder)n        n    End IfnnEnd FunctionnnFunction CLogMoment( _nByRef PriceArray() As Double, _nByVal MomentOrder As Long, _nOptional ByVal DateOrdering As String = "ASC") As DoublennDim i As LongnDim IndexMax As LongnDim IndexMin As LongnDim LogReturn() As Doublenn    IndexMax = UBound(PriceArray)n    IndexMin = LBound(PriceArray)n        n    If IndexMax <= IndexMin + 1 Thenn        n        CLogMoment = -999n        n        Exit Functionn        n    Elsen    n        ReDim LogReturn(IndexMin To IndexMax - 1) As Doublen        n        If LCase(DateOrdering) = LCase("ASC") Thenn        n            For i = IndexMin To IndexMax - 1n                n                LogReturn(i) = Log(PriceArray(i + 1) / PriceArray(i))n            n            Next inn        Elsen        n            For i = IndexMin To IndexMax - 1n            n                LogReturn(i) = Log(PriceArray(i) / PriceArray(i + 1))n            n            Next in        n        End Ifn            n        CLogMoment = CMoment(LogReturn(), MomentOrder)n        n    End IfnnEnd FunctionnnFunction GetDrift( _nByRef PriceArray() As Double, _nOptional ByVal AnnualizeFactor As Long = 252, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetDrift = LogMoment(PriceArray(), 1, DateOrdering) * AnnualizeFactornnEnd FunctionnnFunction GetVol( _nByRef PriceArray() As Double, _nOptional ByVal AnnualizeFactor As Long = 252, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetVol = Sqr(LogMoment(PriceArray(), 2, DateOrdering) * AnnualizeFactor)nnEnd FunctionnnFunction GetCVol( _nByRef PriceArray() As Double, _nOptional ByVal AnnualizeFactor As Long = 252, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetCVol = Sqr(CLogMoment(PriceArray(), 2, DateOrdering) * AnnualizeFactor)nnEnd FunctionnnFunction GetSkew( _nByRef PriceArray() As Double, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetSkew = LogMoment(PriceArray(), 3, DateOrdering) / (GetVol(PriceArray(), 1, DateOrdering) ^ 3)nnEnd FunctionnnFunction GetCSkew( _nByRef PriceArray() As Double, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetCSkew = CLogMoment(PriceArray(), 3, DateOrdering) / (GetCVol(PriceArray(), 1, DateOrdering) ^ 3)nnEnd FunctionnnFunction GetKurtosis( _nByRef PriceArray() As Double, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetKurtosis = LogMoment(PriceArray(), 4, DateOrdering) / (GetVol(PriceArray(), 1, DateOrdering) ^ 4)nnEnd FunctionnnFunction GetCKurtosis( _nByRef PriceArray() As Double, _nOptional ByVal DateOrdering As String = "ASC") As Doublenn    GetCKurtosis = CLogMoment(PriceArray(), 4, DateOrdering) / (GetCVol(PriceArray(), 1, DateOrdering) ^ 4)nnEnd FunctionnnFunction GetCCORR( _nByRef PriceArrayX() As Double, _nByRef PriceArrayY() As Double, _nOptional ByVal DateOrdering As String = "ASC" _n) As DoublennDim i As LongnDim temp As DoublenDim IndexMax As LongnDim IndexMin As LongnDim AverageX As DoublenDim AverageY As Doublenn    temp = 0n    IndexMax = UBound(PriceArrayX)n    IndexMin = LBound(PriceArrayX)n    n    If (IndexMax <= IndexMin) Or ((IndexMax - IndexMin) <> (UBound(PriceArrayY(), 1) - LBound(PriceArrayY(), 1))) Thenn    n        GetCCORR = -999n            n        Exit Functionn        n    Elsen            n        AverageX = GetDrift(PriceArrayX(), 1, DateOrdering)n        AverageY = GetDrift(PriceArrayY(), 1, DateOrdering)n        n        If LCase(DateOrdering) = LCase("ASC") Thenn        n            For i = IndexMin To IndexMax - 1n            n                temp = temp + _n                (Log(PriceArrayX(i + 1) / PriceArrayX(i)) - AverageX) * _n                (Log(PriceArrayY(i + 1) / PriceArrayY(i)) - AverageY) _n                / (IndexMax - IndexMin - 1)n            n            Next in        n        Elsen        n            For i = IndexMin To IndexMax - 1n            n                temp = temp + _n                (Log(PriceArrayX(i) / PriceArrayX(i + 1)) - AverageX) * _n                (Log(PriceArrayY(i) / PriceArrayY(i + 1)) - AverageY) _n                / (IndexMax - IndexMin - 1)n            n            Next in        n        End Ifn        n        GetCCORR = temp / (GetCVol(PriceArrayX(), 1, DateOrdering) * GetCVol(PriceArrayY(), 1, DateOrdering))n        n    End IfnnEnd FunctionnnFunction GetCORR( _nByRef PriceArrayX() As Double, _nByRef PriceArrayY() As Double _n) As DoublennDim i As LongnDim temp As DoublenDim IndexMax As LongnDim IndexMin As Longnn    temp = 0n    IndexMax = UBound(PriceArrayX)n    IndexMin = LBound(PriceArrayX)n    n    If (IndexMax <= IndexMin) Or ((IndexMax - IndexMin) <> (UBound(PriceArrayY(), 1) - LBound(PriceArrayY(), 1))) Thenn    n        GetCORR = -999n            n        Exit Functionn        n    Elsen        n        For i = IndexMin To IndexMax - 1n        n            temp = temp + _n            (Log(PriceArrayX(i + 1) / PriceArrayX(i)) * Log(PriceArrayY(i + 1) / PriceArrayY(i))) _n            / (IndexMax - IndexMin)n        n        Next in    n        GetCORR = temp / (GetVol(PriceArrayX(), 1, "ASC") * GetVol(PriceArrayY(), 1, "ASC"))n        n    End IfnnEnd FunctionnnnPublic Function indicator(condition As Boolean) As Doublenn    If condition Thenn    n        indicator = 1n        n    Elsen        n        indicator = 0n        n    End IfnnEnd Functionnn