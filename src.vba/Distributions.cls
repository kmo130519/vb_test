Option Explicitnn'Reference Papers - ykjeonn'1) Better approximations to cumulative normal functions - Graeme westn'2) A short note on the numerical approximatioin of standard normal cumulative distribution and its inverse - Dridin'3) Numerical computation of rectangular bivariate and trivariate normal and t probabilities  - Alan GenznnConst pi As Double = 3.14159265358979nConst tiny As Double = 0.0000000001nConst one As Double = 0.9999999999nnPublic Function NormInv(ByVal p As Double) As Doublenn'  Adapted for Microsoft Visual Basic from Peter Acklam'sn'  This Algorithm originally written by John Herrero(2003-01-03)n'  for more details visit the site, [http://home.online.no/~pjacklam/notes/invnorm/]nn'Define coefficients in rational approximationsnn'This function returns a inverse value of standard normal cumulative density functionn'i.e. returns x such that Prob[Z <= x] = p where Z is a standard normal random variable is - ykjeonnnConst A1 = -39.6968302866538nConst A2 = 220.946098424521nConst A3 = -275.928510446969nConst a4 = 138.357751867269nConst a5 = -30.6647980661472nConst a6 = 2.50662827745924nnConst b1 = -54.4760987982241nConst b2 = 161.585836858041nConst b3 = -155.698979859887nConst b4 = 66.8013118877197nConst b5 = -13.2806815528857nnConst c1 = -7.78489400243029E-03nConst C2 = -0.322396458041136nConst c3 = -2.40075827716184nConst c4 = -2.54973253934373nConst c5 = 4.37466414146497nConst c6 = 2.93816398269878nnConst d1 = 7.78469570904146E-03nConst d2 = 0.32246712907004nConst d3 = 2.445134137143nConst d4 = 3.75440866190742nn'Define break-pointsnConst p_low = 0.02425nConst p_high = 1 - p_lownn'Define work variablesnDim q As Double, r As Doublenn'If argument out of bounds, raise errornIf p <= 0 Or p >= 1 Thennn    MsgBox "INPUT IS OUT OF RANGE"n    Exit Functionn    nEnd IfnnIf p < p_low Thenn  'Rational approximation for lower regionn  q = Sqr(-2 * Log(p))n  NormInv = (((((c1 * q + C2) * q + c3) * q + c4) * q + c5) * q + c6) / _n    ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)nElseIf p <= p_high Thenn  'Rational approximation for lower regionn  q = p - 0.5n  r = q * qn  NormInv = (((((A1 * r + A2) * r + A3) * r + a4) * r + a5) * r + a6) * q / _n    (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1)nElseIf p < 1 Thenn  'Rational approximation for upper regionn  q = Sqr(-2 * Log(1 - p))n  NormInv = -(((((c1 * q + C2) * q + c3) * q + c4) * q + c5) * q + c6) / _n    ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)nEnd IfnnEnd FunctionnnPublic Function NormCDF(ByVal x As Double) As Doublenn'This function returns Prob[Z <= x] where Z is a standard normal random variable - ykjeonnnDim xabs As DoublenDim temp As DoublenDim Exponential As Doublennxabs = Abs(x)nnIf xabs > 37 Thennn    NormCDF = 0nnElsenn    Exponential = Exp(-0.5 * xabs * xabs)n    n    If xabs < 7.07106781186547 Thenn    n        temp = 3.52624965998911E-02 * xabs + 0.700383064443688n        temp = temp * xabs + 6.37396220353165n        temp = temp * xabs + 33.912866078383n        temp = temp * xabs + 112.079291497871n        temp = temp * xabs + 221.213596169931n        temp = temp * xabs + 220.206867912376n        n        NormCDF = Exponential * tempn        n        temp = 8.83883476483184E-02 * xabs + 1.75566716318264n        temp = temp * xabs + 16.064177579207n        temp = temp * xabs + 86.7807322029461n        temp = temp * xabs + 296.564248779674n        temp = temp * xabs + 637.333633378831n        temp = temp * xabs + 793.826512519948n        temp = temp * xabs + 440.413735824752n        n        NormCDF = NormCDF / tempn    n    Elsen    temp = xabs + 0.65n    temp = xabs + 4 / tempn    temp = xabs + 3 / tempn    temp = xabs + 2 / tempn    temp = xabs + 1 / tempn    NormCDF = (Exponential / temp) / 2.506628274631n    n    End IfnnEnd IfnnIf x > 0 Thennn    NormCDF = 1 - NormCDFn    nEnd IfnnEnd FunctionnnPublic Function NormD( _nByVal x As Double, _nOptional ByVal Mean As Double = 0, _nOptional ByVal sigma As Double = 1) As Doublenn'This function returns a value of standard normal density function at x - ykjeonnn    NormD = 1 / (sigma * Sqr(2 * pi)) * Exp(-0.5 * (x - Mean) * (x - Mean) / (sigma * sigma))nnEnd FunctionnnPublic Function BiNormCDFDW2( _nByVal a As Double, _nByVal b As Double, _nByVal r As Double) _nAs Doublenn'This approximation was developed by Drezner & Wesolowskyn'as their second verison(thus, DW2) in 1989n'DW2 method is single precisionnnDim i As IntegernDim x As Variant, w As VariantnDim h1 As Double, h2 As DoublenDim LH As Double, h12 As DoublenDim h3 As Double, h5 As Double, h6 As Double, h7 As DoublenDim r1 As Double, r2 As Double, r3 As Double, rr As DoublenDim AA As Double, ab As DoublennOn Error GoTo ErrorHandlernnx = Array(0.04691008, 0.23076534, 0.5, 0.76923466, 0.95308992)nw = Array(0.018854042, 0.038088059, 0.0452707394, 0.038088059, 0.018854042)nh1 = anh2 = bnnh12 = (h1 * h1 + h2 * h2) / 2nn    If Abs(r) >= 0.7 Thenn        r2 = 1 - r * rn        r3 = Sqr(r2)n        n        If r < 0 Then h2 = -h2n        n        h3 = h1 * h2n        h7 = Exp(-h3 / 2)n        n        If Abs(r) < 1 Thenn        n            h6 = Abs(h1 - h2)n            h5 = h6 * h6 / 2n            h6 = h6 / r3n            AA = 0.5 - h3 / 8n            ab = 3 - 2 * AA * h5n            LH = 0.13298076 * h6 * ab * (1 - NormCDF(h6)) _n            - Exp(-h5 / r2) * (ab + AA * r2) * 0.053051647n            n            For i = 0 To 4n            n                r1 = r3 * x(i)n                rr = r1 * r1n                r2 = Sqr(1 - rr)n                LH = LH - w(i) * Exp(-h5 / rr) * (Exp(-h3 / (1 + r2)) / r2 / h7 - 1 - AA * rr)n            n            Next in            n        End Ifn            n        BiNormCDFDW2 = LH * r3 * h7 + NormCDF((h1 + h2 - Abs(h1 - h2)) / 2)n            n        If r < 0 Thenn        n            BiNormCDFDW2 = NormCDF(h1) - BiNormCDFDW2n            n        End Ifn        n    Elsen        h3 = h1 * h2n        n        If r <> 0 Thenn        n            For i = 0 To 4n            n                r1 = r * x(i)n                r2 = 1 - r1 * r1n                LH = LH + w(i) * Exp((r1 * h3 - h12) / r2) / Sqr(r2)n            n            Next in            n        End Ifn        n        BiNormCDFDW2 = NormCDF(h1) * NormCDF(h2) + r * LHn        n    End Ifn    nExit FunctionnnErrorHandler:n    n    MsgBox "ERROR IN BINORMAL APPROX."n    Exit Functionn    nEnd Functionnn'General Brownian motion Z(t) = a*t + b*dB(t) (where a and b are constans, B(t) is standard Brownian motion)n'Geometric Brownian Motion G(t) = exp(Z(t)) - ykjeonnnPublic Function GeneralBMCDF( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double)nn'This function returns Prob[Z(t) <= x] where a = mu, b = sigma - ykjeonnn    GeneralBMCDF = NormCDF((x - Mu * t) / (sigma * Sqr(t)))nnEnd FunctionnnPublic Function GeneralMinima( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double) As Doublenn'This function returns Prob[m(t) <= x] where m(t) = min{Z(s): 0<= s <= t} - ykjeonnn    GeneralMinima = Exp(2 * Mu * x / (sigma * sigma)) * NormCDF((x + Mu * t) / (sigma * Sqr(t))) + _n    GeneralBMCDF(sigma, Mu, t, x)nnEnd FunctionnnPublic Function GeneralMaxima( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double) As Doublenn'This function returns Prob[M(t) >= x] where M(t) = max{Z(s): 0<= s <= t} - ykjeonnn    GeneralMaxima = Exp(2 * Mu * x / (sigma * sigma)) * NormCDF((-x - Mu * t) / (sigma * Sqr(t))) + _n    (1 - GeneralBMCDF(sigma, Mu, t, x))nnEnd FunctionnnPublic Function GeometricBMCDF( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double)nn'This function returns Prob[G(t) <= x] (recall G(t) denotes a geometric Brownian motion) - ykjeonnn    GeometricBMCDF = GeneralBMCDF(sigma, Mu, t, Log(x))nnEnd FunctionnnPublic Function GeometricMinima( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double) As Doublenn'This function return Prob[m(t) <= x] where m(t) = min{(G(s): 0 <= s <= t} - ykjeonnn    GeometricMinima = GeneralMinima(sigma, Mu, t, Log(x))n    nEnd FunctionnnPublic Function GeometricMaxima( _nByVal sigma As Double, _nByVal Mu As Double, _nByVal t As Double, _nByVal x As Double) As Doublenn'This function returns Prob[M(t) >= x] where M(t) = max{G(s): 0<= s <= t} - ykjeonnn    GeometricMaxima = GeneralMaxima(sigma, Mu, t, Log(x))nnEnd Functionn